package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"unicode"

	"github.com/alecthomas/repr"
	bmwcardata "github.com/tjamet/bmw-cardata"
	"golang.org/x/net/html"
)

const (
	AuthSwaggerURL = "https://bmw-cardata.bmwgroup.com/customer/public/assets/swagger/swagger-device-code-flow.json"
	CarDataSwagger = "https://bmw-cardata.bmwgroup.com/customer/public/assets/swagger/swagger-customer-api-v1.json"
)

func saveSwagger(url string, path string) error {
	os.MkdirAll(filepath.Dir(path), 0755)
	response, err := http.Get(url)
	if err != nil {
		return err
	}
	defer response.Body.Close()

	body, err := io.ReadAll(response.Body)
	if err != nil {
		return err
	}
	return os.WriteFile(path, body, 0644)
}

func toSnakeCase(s string) string {
	b := strings.Builder{}
	upper := true
	for _, r := range s {
		if r == '_' {
			upper = true
			continue
		}
		if upper {
			b.WriteRune(unicode.ToUpper(r))
			upper = false
		} else {
			b.WriteRune(unicode.ToLower(r))
		}
	}
	return b.String()
}

func getCatalogue(url string, offset int) (*GetContainersResponse, error) {
	response, err := http.Get(url + "?offset=" + strconv.Itoa(offset))
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()

	catalogue := GetContainersResponse{}
	err = json.NewDecoder(response.Body).Decode(&catalogue)
	if err != nil {
		return nil, err
	}
	return &catalogue, nil
}

func BuildContainers(url string, path string) error {
	allCategories := map[string]bmwcardata.Category{}
	allContainers := map[string]bmwcardata.Descriptor{}

	// TODO: http
	offset := 0

	for {
		catalogue, err := getCatalogue(url, offset)
		if err != nil {
			return err
		}

		fmt.Printf("Handling catalogue starting at %d over %d\n", offset, catalogue.Data.Total)

		for name, category := range catalogue.Data.Categories {
			if _, ok := allCategories[name]; ok {
				continue
			}
			allCategories[name] = bmwcardata.Category{
				Description: category.Description,
				Rank:        category.Rank,
				Name:        name,
				Containers:  []bmwcardata.Descriptor{},
			}
		}

		for _, container := range catalogue.Data.Items {
			cat := allCategories[container.Category]
			cat.Containers = append(cat.Containers, container)
			allCategories[container.Category] = cat
			allContainers[container.ID] = container
		}
		if catalogue.Data.HasNextPage {
			offset += catalogue.Data.PageSize
		} else {
			break
		}
	}

	b := strings.Builder{}

	fmt.Fprintln(&b, "package bmwcardata")
	fmt.Fprintln(&b, "// Code generated by github.com/tjamet/bmw-cardata/cmd/generate. DO NOT EDIT.")
	fmt.Fprintln(&b, "var (")

	reprWriter := repr.New(&b)

	for _, category := range allCategories {
		name := toSnakeCase(category.Name)
		fmt.Fprintf(&b, "// %s %s\n", name, category.Description)
		fmt.Fprintf(&b, "%s =", name)
		reprWriter.Print(category)
		fmt.Fprintln(&b)
	}

	fmt.Fprint(&b, "allContainers = ")
	reprWriter.Print(allContainers)
	fmt.Fprintln(&b)
	fmt.Fprintln(&b, ")")

	fd, err := os.Create(path)
	if err != nil {
		return err
	}
	defer fd.Close()
	_, err = fd.WriteString(
		strings.Replace(
			strings.Replace(b.String(), "bmwcardata.", "", -1),
			": Container{", ":{", -1,
		),
	)
	if err != nil {
		return err
	}

	err = exec.Command("go", "fmt", path).Run()
	if err != nil {
		return err
	}

	return nil
}

func getTagString(w io.Writer, n *html.Node) {
	//getTagString(w, n.FirstChild)
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		if c.Type == html.TextNode {
			w.Write([]byte(c.Data))
		}
		getTagString(w, c)
	}
}

var (
	reasonCodeRe = regexp.MustCompile(`0x[0-9A-Fa-f]+ \(([0-9]+)\)`)
)

func parseMQTTErrorRow(row []string) *bmwcardata.MQTTReasonCode {
	reasonCode := reasonCodeRe.FindStringSubmatch(row[0])
	if len(reasonCode) != 2 {
		return nil
	}
	reasonCodeInt, err := strconv.Atoi(reasonCode[1])
	if err != nil {
		return nil
	}
	packets := []string{}
	for _, packet := range strings.Split(row[2], ",") {
		packet = strings.TrimSpace(packet)
		if packet == "" {
			continue
		}
		packets = append(packets, packet)
	}

	return &bmwcardata.MQTTReasonCode{
		ReasonCode: bmwcardata.ReasonCode(reasonCodeInt),
		Name:       row[1],
		Packets:    packets,
		Details:    row[3],
	}
}

func generateMQTTCodes(dest string) error {
	resp, err := http.Get("https://www.emqx.com/en/blog/mqtt5-new-features-reason-code-and-ack")
	if err != nil {
		log.Fatalf("Failed to get mqtt5 reason code and ack: %v", err)
	}
	defer resp.Body.Close()

	doc, err := html.Parse(resp.Body)
	if err != nil {
		log.Fatalf("Failed to parse mqtt5 reason code and ack: %v", err)
	}
	var tables []*html.Node
	var f func(*html.Node)
	f = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == "div" {
			for _, a := range n.Attr {
				if a.Key == "class" && (a.Val == "blog-body" || a.Val == "content") {
					// Found blog-body or content div, look for tables within it
					var findTables func(*html.Node)
					findTables = func(n *html.Node) {
						if n.Type == html.ElementNode && n.Data == "table" {
							tables = append(tables, n)
						}
						for c := n.FirstChild; c != nil; c = c.NextSibling {
							findTables(c)
						}
					}
					findTables(n)
				}
			}
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(doc)
	if len(tables) != 1 {
		return fmt.Errorf("expected 1 table, got %d", len(tables))
	}
	tables[0].Type = html.ElementNode

	headers := []string{}

	errors := map[bmwcardata.ReasonCode]bmwcardata.MQTTReasonCode{}

	for c := tables[0].FirstChild; c != nil; c = c.NextSibling {
		if c.Type == html.ElementNode && c.Data == "thead" {
			for c := c.FirstChild; c != nil; c = c.NextSibling {
				if c.Type == html.ElementNode && c.Data == "tr" {
					for c := c.FirstChild; c != nil; c = c.NextSibling {
						if c.Type == html.ElementNode && c.Data == "th" {
							b := bytes.Buffer{}
							getTagString(&b, c)
							headers = append(headers, b.String())
						}
					}
				}
			}
		}
		if c.Type == html.ElementNode && c.Data == "tbody" {
			for c := c.FirstChild; c != nil; c = c.NextSibling {
				if c.Type == html.ElementNode && c.Data == "tr" {
					row := []string{}
					for c := c.FirstChild; c != nil; c = c.NextSibling {
						if c.Type == html.ElementNode && c.Data == "td" {
							b := bytes.Buffer{}
							getTagString(&b, c)
							row = append(row, b.String())
						}
					}
					parsed := parseMQTTErrorRow(row)
					if parsed != nil {
						errors[parsed.ReasonCode] = *parsed
					}
				}
			}
		}
	}
	expectedHeaders := []string{"Reason Code", "Name", "Packets", "Details"}
	for i, header := range expectedHeaders {
		if headers[i] != header {
			return fmt.Errorf("mqtt documentation page layout seems to have changed, expected header %v, got %v", expectedHeaders, headers)
		}
	}
	fd, err := os.Create(dest)
	if err != nil {
		return err
	}
	defer fd.Close()
	b := bytes.Buffer{}
	reprWriter := repr.New(&b)
	fmt.Fprintf(&b, "package bmwcardata\n")
	fmt.Fprintf(&b, "// Code generated by github.com/tjamet/bmw-cardata/cmd/generate. DO NOT EDIT.\n")
	fmt.Fprintf(&b, "var (\n")
	fmt.Fprintf(&b, "mqttReasonCodes = ")
	reprWriter.Print(errors)
	fmt.Fprintf(&b, ")\n")
	_, err = fd.WriteString(strings.Replace(b.String(), "bmwcardata.", "", -1))
	if err != nil {
		return err
	}
	err = fd.Sync()
	if err != nil {
		return err
	}
	err = exec.Command("go", "fmt", dest).Run()
	if err != nil {
		return err
	}
	return nil
}

func main() {

	err := generateMQTTCodes("zzmqtt_errors.go")
	if err != nil {
		log.Fatalf("Failed to generate mqtt codes: %v", err)
	}

	return

	err = BuildContainers("https://www.bmw.de/en-en/utilities/bmw/api/cd/catalogue", "zzcontainers_data.go")
	if err != nil {
		log.Fatalf("Failed to build containers: %v", err)
	}

	err = saveSwagger(AuthSwaggerURL, "swagger/auth.json")
	if err != nil {
		log.Fatalf("Failed to save auth swagger: %v", err)
	}

	err = saveSwagger(CarDataSwagger, "swagger/cardataapi.json")
	if err != nil {
		log.Fatalf("Failed to save customer api swagger: %v", err)
	}

}
